```
能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性，子问题重叠。
```


入门DP：
    最大子数组和： # Kadane 算法
        定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是 f[i] = a[i]，和 i 左边拼起来就是 f[i] = f[i−1] + a[i]，
        取最大值就得到了状态转移方程 f[i] = max(f[i−1], 0) + a[i]，答案为 max(f)

划分型DP：
    将数组分成（恰好/至多）k 个连续子数组，计算与这些子数组有关的最优值。
    一般定义 f[i][j] 表示将长为 j 的前缀 a[:j] 分成 i 个连续子数组所得到的最优解。
    枚举最后一个子数组的左端点 L, 从 f[i−1][L] 转移到 f[i][j]，并考虑 a[L:j] 对最优解的影响。
